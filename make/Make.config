# $Id: Make.config,v 1.429.8.1.4.2 Broadcom SDK $
# $Copyright: (c) 2016 Broadcom.
# Broadcom Proprietary and Confidential. All rights reserved.$
#
# Make command configuration for SOC driver and diags.

ALLOWED_MAKE_VERSIONS :=3.81 3.82 4.0 4.1

MAKE_VERSION_IS_SUPPORTED := $(strip $(foreach v,$(ALLOWED_MAKE_VERSIONS), $(findstring $v,$(MAKE_VERSION))))
ifeq ($(MAKE_VERSION_IS_SUPPORTED),)
# {
$(error Make $(MAKE_VERSION) not supported, use one of $(ALLOWED_MAKE_VERSIONS))
# }
endif


ifeq (${BCM_HIDE_DISPATCHABLE},1)
# {
CFGFLAGS += -DBCM_HIDE_DISPATCHABLE
# }
endif

ifeq (${WAN_PORT_SUPPORT},1)
# {
CFGFLAGS += -DWAN_PORT_SUPPORT
# }
endif

ifeq (${IPROC_NO_ATL},1)
# {
CFGFLAGS += -DIPROC_NO_ATL
# }
endif

#
# Set a default target if one is not set. If override-target is set,
# then the target will become override-target and a warning is printed
# if the assigned TARGET was different.
#
ifneq ($(strip $(override-target)),)
# {
override TARGET=$(override-target)
# }
endif

#
# If TARGET is not set, default to a Unix target based on host type
#
ifndef TARGET
# {
 uname := $(shell uname -s)
 ifeq ($(filter-out Linux Darwin,$(uname)),)
  ifeq ($(shell uname -m),x86_64)
   TARGET=unix-linux-64
  else
   TARGET=unix-linux
  endif
 endif
 ifeq ($(uname),SunOS)
  TARGET=unix-solaris
 endif
 ifeq ($(uname),NetBSD)
  TARGET=unix-netbsd
 endif
 ifndef	TARGET
  $(error Cannot determine TARGET in Make.config, uname = $(uname))
 endif
# }
endif

export TARGET


#
# Set up the target name, and the target base variables.
#
# target = The full name of the target such as vxworks-bmw
# targetbase = 1st part of target (e.g. vxworks)
# targetplat = 2nd part of target (e.g. x86) if any; otherwise same as 1st
#
target     = ${TARGET}
targetsplt = $(subst -, , ${target})	# change hyphens to spaces
targetbase = $(word 1,${targetsplt})
targetplat = $(subst ${targetbase}-,,${TARGET})
#targetplat = $(lastword ,${targetsplt})

#
# Common configuration for all platforms
# (Additional platform-dependent configurations are in Makefile.xxx)
#

#
# THIS FILE SHOULD NOT BE MODIFIED LOCALLY, to override, add a file
# $SDK/make/Make.local that sets your local settings, and/or provide
# a path to your settings using the MAKE_LOCAL variable.  If 
# either of these files exists, their values will override those in this makefile.
#
ifdef MAKE_LOCAL
# {
include        ${MAKE_LOCAL}
# }
else
# {
-include	${SDK}/make/Make.local
# }
endif


# Make sure some chip is supported

SBX_CALADAN_DEVICES = BCM_88030_A0 BCM_88030_A1 BCM_88030_B0
#
# Caladan devices are not supported when compiling for Linux kernel mode
#
ifndef LINUX_MAKE_KERNEL
# {
    SUPPORTED_CALADAN_DEVICES = $(SBX_CALADAN_DEVICES)
# }
endif
ifndef SUPPORTED_CALADAN_DEVICES
# {
    CFGFLAGS += $(strip $(foreach chipname,$(SBX_CALADAN_DEVICES),\
                          -DNO_$(chipname) \
                          $(eval export NO_$(chipname) = 1)))
    SUPPORTED_CALADAN_DEVICES =
# }
endif
SBX_CHIP_NAMES = BCM_QE2000_A0 BCM_BME3200_A0 BCM_BME3200_B0 \
  BCM_BM9600_A0 BCM_88230_A0 BCM_88230_B0 BCM_88230_C0 BCM_BM9600_B0 \
  $(SUPPORTED_CALADAN_DEVICES)

# Here list EA chipsets
EA_CHIP_NAMES = BCM_TK371X_A0

ROBO_CHIP_NAMES = BCM_53242_A0 BCM_53262_A0 BCM_53115_A0 BCM_53118_A0 \
  BCM_53280_A0 BCM_53280_B0 BCM_53101_A0 BCM_53125_A0 BCM_53134_A0 BCM_53134_B0 BCM_53128_A0 BCM_53600_A0 \
  BCM_89500_A0 BCM_53010_A0 BCM_5389_A0 BCM_53020_A0 BCM_5396_A0
ESW_CHIP_NAMES = BCM_5675_A0 BCM_56504_A0 BCM_56504_B0 BCM_56314_A0 BCM_56112_A0 \
  BCM_56304_B0 BCM_56102_A0 BCM_56580_A0 BCM_56700_A0 BCM_56800_A0 BCM_56218_A0 \
  BCM_56514_A0 BCM_56624_A0 BCM_56680_A0 BCM_56680_B0 BCM_56224_A0 BCM_56224_B0 BCM_56820_A0 \
  BCM_53314_A0 BCM_56725_A0 BCM_56624_B0 BCM_56634_A0 BCM_56634_B0 \
  BCM_56524_A0 BCM_56524_B0 BCM_56685_A0 BCM_56685_B0 BCM_56334_A0 BCM_56334_B0 \
  BCM_56840_A0 BCM_56840_B0 BCM_56142_A0 BCM_53324_A0 BCM_88732_A0 BCM_56440_A0 \
  BCM_56440_B0 BCM_56640_A0 BCM_56850_A0 BCM_56450_A0 BCM_56450_B0 BCM_56450_B1 BCM_56340_A0 \
  BCM_56150_A0 BCM_53400_A0 BCM_56960_A0 BCM_56860_A0 BCM_56560_A0 BCM_56260_A0 BCM_56260_B0 \
  BCM_56160_A0 BCM_56560_B0 BCM_56270_A0 BCM_56965_A0 BCM_56970_A0 BCM_53570_A0

DPP_CHIP_NAMES = BCM_88650_A0 BCM_88650_B0 BCM_88660_A0 BCM_88675_A0 BCM_88675_B0 BCM_88375_A0 BCM_88375_B0 BCM_88680_A0 BCM_88470_A0 BCM_88470_B0 BCM_88270_A0 BCM_8206_A0 BCM_88202_A0
DFE_CHIP_NAMES = BCM_88750_A0 BCM_88750_B0 BCM_88754_A0 BCM_88950_A0 BCM_88950_A1 BCM_88770_A1
DNX_CHIP_NAMES = BCM_88690_A0
DNXF_CHIP_NAMES = BCM_88790_A0

whereischip = $(origin $(chipname))
seekrob = $(foreach chipname,$(ROBO_CHIP_NAMES),$(whereischip))
seekesw = $(foreach chipname,$(ESW_CHIP_NAMES),$(whereischip))
seeksbx = $(foreach chipname,$(SBX_CHIP_NAMES),$(whereischip))
seekea  = $(foreach chipname,$(EA_CHIP_NAMES),$(whereischip))
seekdpp = $(foreach chipname,$(DPP_CHIP_NAMES),$(whereischip))
seekdfe = $(foreach chipname,$(DFE_CHIP_NAMES),$(whereischip))
seekdnx = $(foreach chipname,$(DNX_CHIP_NAMES),$(whereischip))
seekdnxf = $(foreach chipname,$(DNXF_CHIP_NAMES),$(whereischip))
 
setallsbx = $(foreach chipname,$(SBX_CHIP_NAMES),$(eval export $(chipname) = 1))
setallesw = $(foreach chipname,$(ESW_CHIP_NAMES),$(eval export $(chipname) = 1))
setallrob = $(foreach chipname,$(ROBO_CHIP_NAMES),$(eval export $(chipname) = 1))
setallea  = $(foreach chipname,$(EA_CHIP_NAMES),$(eval export $(chipname) = 1))
setalldpp = $(foreach chipname,$(DPP_CHIP_NAMES),$(eval export $(chipname) = 1))
setalldfe = $(foreach chipname,$(DFE_CHIP_NAMES),$(eval export $(chipname) = 1))
setalldnx = $(foreach chipname,$(DNX_CHIP_NAMES),$(eval export $(chipname) = 1))
setalldnxf = $(foreach chipname,$(DNXF_CHIP_NAMES),$(eval export $(chipname) = 1))

ifeq (1,$(PORTMOD_STAND_ALONE))
# {
export PORTMOD_STAND_ALONE
BCM_PTL_SPT=1
PHYMOD_SUPPORT=1
PORTMOD_SUPPORT=1
CFLAGS += -DPORTMOD_STAND_ALONE
# }
endif
#
# If any of DNX_CHIPS or DNXF_CHIPS is set (Jericho 2 or corresponding fabric)
# then set a make-level variable: DNX_DNXF_CHIPS
#
ifdef BCM_PTL_SPT
# {

  ifdef ALL_SBX_CHIPS
    $(setallsbx)
    export BCM_SBX_SUPPORT = 1
  endif

  ifdef ALL_ESW_CHIPS
    $(setallesw)
    export BCM_ESW_SUPPORT = 1
    export BCM_ALL_CHIPS = 1
    CFGFLAGS+=-DBCM_ALL_CHIPS
  endif

  ifdef ALL_ROBO_CHIPS
    $(setallrob)
    export BCM_ROBO_SUPPORT = 1
  endif
  
  ifdef ALL_EA_CHIPS 
    $(setallea)
    export BCM_EA_SUPPORT = 1
    export BCM_TK371X_SUPPORT = 1
    export EA_CHIPS = 1
  else
	ifdef EA_CHIPS
	  export BCM_EA_SUPPORT = 1
	endif
	ifdef EA_CHIPS
	ifndef BCM_TK371X_A0
	  export BCM_TK371X_SUPOORT = 1
	endif
	endif
	ifndef EA_CHIPS
	ifdef BCM_TK371X_A0  
	export BCM_EA_SUPPORT = 1
	export BCM_TK371X_SUPPORT = 1
	endif
	endif
	ifdef BCM_EA_SUPPORT
	  export EA_CHIPS = 1
	  ifndef BCM_TK371X_SUPPORT
           $(setallea)
	   export BCM_TK371X_SUPPORT = 1
	  endif
	endif # BCM_EA_SUPPORT
  endif # ALL_EA_CHIPS
  
  ifdef ALL_DPP_CHIPS
    $(setalldpp)
  endif

  ifdef ALL_DFE_CHIPS
    $(setalldfe)
  endif

  ifdef ALL_DNX_CHIPS
    $(setalldnx)
  endif

  ifdef ALL_DNXF_CHIPS
    $(setalldnxf)
  endif

  ifneq "$(findstring file,$(seekrob))" ""
    ROBO_CHIPS = 1
    export ROBO_CHIPS
  endif

  ifneq "$(findstring file,$(seekesw))" ""
    ESW_CHIPS = 1
  endif

  ifneq "$(findstring file,$(seeksbx))" ""
    SBX_CHIPS = 1
  endif
  ifneq "$(findstring environment,$(seeksbx))" ""
    SBX_CHIPS = 1
  endif

  ifneq "$(findstring file,$(seekea))" ""
    EA_CHIPS = 1
    export EA_CHIPS = 1
  endif
  
  ifneq "$(findstring file,$(seekdpp))" ""
    DPP_CHIPS = 1
    export DPP_CHIPS
  endif
  
  ifneq "$(findstring file,$(seekdfe))" ""
    DFE_CHIPS = 1
    export DFE_CHIPS
  endif
  
  ifneq "$(findstring file,$(seekdnx))" ""
    DNX_CHIPS = 1
    export DNX_CHIPS
  endif

  ifneq "$(findstring file,$(seekdnxf))" ""
    DNXF_CHIPS = 1
    export DNXF_CHIPS
  endif

ifndef ROBO_CHIPS
# {
ifndef ESW_CHIPS
# {
ifndef SBX_CHIPS
# {
ifndef EA_CHIPS
# {
ifndef DPP_CHIPS
# {
ifndef DFE_CHIPS
# {
ifndef DNX_CHIPS
# {
ifndef DNXF_CHIPS
# {
ifndef PORTMOD_STAND_ALONE #Compile without chips is allowed in case of portmod stand alone
# {
ifneq (C_COMPILER,$(MAKECMDGOALS))
# {
  $(error "BCM_PTL_SPT defined, and no valid chip names were defined")
# }
endif
# }
endif
# }
endif
# }
endif
# }
endif
# }
endif
# }
endif
# }
endif
# }
endif
# }
endif

# }
else # BCM_PTL_SPT
# {

ifdef ALL_CHIPS
# {
  ROBO_CHIPS = 1
  ESW_CHIPS = 1
  SBX_CHIPS = 1
  EA_CHIPS = 1
  DPP_CHIPS = 1
  DFE_CHIPS = 1
  DNX_CHIPS = 1
  DNXF_CHIPS = 1

  export ROBO_CHIPS
# }
else
# {
  # BCM5836/4704 ROBO Build
  ifdef ROBO_CHIPS
    export ROBO_CHIPS
  else
    # Chekc if Keystone build,
    # enable ROBO_CHIPS by default for single image target
    ifdef KS_BUILD
      # Check if ROBO is in dispatch list, build only when present
      ifdef DISPATCH_LIST
        ifneq "$(findstring ROBO,$(DISPATCH_LIST))" ""
          ROBO_CHIPS = 1
          export ROBO_CHIPS
          export BCM_EA_SUPPORT = 1
	      export BCM_TK371X_SUPPORT = 1
        endif
      else
        ROBO_CHIPS = 1
        export ROBO_CHIPS
        export BCM_EA_SUPPORT = 1
	export BCM_TK371X_SUPPORT = 1
      endif
    endif

    # Check IPROC build,
    # enable ROBO_CHIPS by default for single image target
    ifdef IPROC_BUILD
      # Check if ROBO is in dispatch list, build only when present
      ifdef DISPATCH_LIST
        ifneq "$(findstring ROBO,$(DISPATCH_LIST))" ""
          ROBO_CHIPS = 1
          export ROBO_CHIPS
        endif
      else
        ROBO_CHIPS = 1
        export ROBO_CHIPS
      endif
    endif

    ifndef ESW_CHIPS
	  ifndef SBX_CHIPS
	    # Check if ESW support exist
	    ifeq ($(shell test -d $(SDK)/src/bcm/esw; echo $$?),0)
      		ESW_CHIPS = 1
      		export ESW_CHIPS
      	endif
      endif
    endif
  endif # ROBO_CHIPS

  ifdef ALL_EA_CHIPS
  	export BCM_EA_SUPPORT = 1
	export BCM_TK371X_SUPPORT = 1
  	export EA_CHIPS = 1
        $(setallea)  
  else
	ifdef EA_CHIPS
	  export BCM_EA_SUPPORT = 1
	endif   
	ifdef EA_CHIPS
	ifndef BCM_TK371X_A0
	  export BCM_TK371X_SUPOORT = 1
	endif
	endif
	ifndef EA_CHIPS
	ifdef BCM_TK371X_A0  
	export BCM_EA_SUPPORT = 1
	export BCM_TK371X_SUPPORT = 1
	endif
	endif
	ifdef BCM_EA_SUPPORT
	  export EA_CHIPS = 1
	  ifndef BCM_TK371X_SUPPORT
	    export BCM_TK371X_SUPPORT = 1
	  endif
	endif # BCM_EA_SUPPORT
  endif # ALL_EA_CHIPS

  ifdef ALL_DPP_CHIPS
    DPP_CHIPS=1
    export DPP_CHIPS
  endif

  ifdef ALL_DFE_CHIPS
    DFE_CHIPS=1
    export DFE_CHIPS
  endif

  ifdef ALL_DNX_CHIPS
    DNX_CHIPS=1
    export DNX_CHIPS
  endif

  ifdef ALL_DNXF_CHIPS
    DNXF_CHIPS=1
    export DNXF_CHIPS
  endif

# }
endif # ALL_CHIPS

# }
endif # BCM_PTL_SPT

#
# Check for incompatible reload options
#

ifneq (,$(findstring -DBCM_WARM_BOOT_SUPPORT,$(CFGFLAGS)))
# {
ifneq (,$(findstring -DBCM_EASY_RELOAD_SUPPORT,$(CFGFLAGS)))
# {
 $(error "BCM_WARM_BOOT_SUPPORT and BCM_EASY_RELOAD_SUPPORT should not be enabled at the same time")
# }
endif
# }
endif

#
# By default, turn off the "changing directory" message.
#

MAKEFLAGS += --no-print-directory

#
# Use gmake by default
#

include ${SDK}/make/Make.tools
include	${SDK}/make/Makefile.${target}

# For make v3.80, eval function can't be placed inside any ifxxx-endif section
# The bug is fixed in v3.81
eval_fixed_ver := 3.81
eval_fixed := $(filter $(eval_fixed_ver),$(firstword $(sort $(MAKE_VERSION) $(eval_fixed_ver))))

# See Make.local (Make.local.template) to configure chip support

ifndef BCM_PTL_SPT
# {

# Support all chips by default
CFGFLAGS += -DBCM_ALL_CHIPS

ifdef ROBO_CHIPS
# {
ifeq ($(eval_fixed),$(eval_fixed_ver))
# {
$(setallrob)
# }
else
# {
BCM_53242_A0 = 1
BCM_53262_A0 = 1
BCM_53115_A0 = 1
BCM_53118_A0 = 1
BCM_53280_A0 = 1
BCM_53280_B0 = 1
BCM_53101_A0 = 1
BCM_53125_A0 = 1
BCM_53134_A0 = 1
BCM_53134_B0 = 1
BCM_53128_A0 = 1
BCM_53600_A0 = 1
BCM_89500_A0 = 1
BCM_53010_A0 = 1
BCM_5389_A0 = 1
BCM_53020_A0 = 1
BCM_5396_A0 = 1
# }
endif
# }
endif

ifdef ESW_CHIPS
# {
ifeq ($(eval_fixed),$(eval_fixed_ver))
# {
$(setallesw)
# }
else
# {
BCM_5675_A0 = 1
BCM_56504_A0 = 1
BCM_56504_B0 = 1
BCM_56314_A0 = 1
BCM_56112_A0 = 1
BCM_56304_B0 = 1
BCM_56102_A0 = 1
BCM_56580_A0 = 1
BCM_56700_A0 = 1
BCM_56800_A0 = 1
BCM_56218_A0 = 1
BCM_56514_A0 = 1
BCM_56624_A0 = 1
BCM_56224_A0 = 1
BCM_56224_B0 = 1
BCM_56820_A0 = 1
BCM_53314_A0 = 1
BCM_56725_A0 = 1
BCM_56624_B0 = 1
BCM_56634_A0 = 1
BCM_56634_B0 = 1
BCM_56524_A0 = 1
BCM_56524_B0 = 1
BCM_56685_A0 = 1
BCM_56685_B0 = 1
BCM_56334_A0 = 1
BCM_56334_B0 = 1
BCM_56840_A0 = 1
BCM_56840_B0 = 1
BCM_56142_A0 = 1
BCM_53324_A0 = 1
BCM_56440_A0 = 1
BCM_56440_B0 = 1
BCM_56450_A0 = 1
BCM_56450_B0 = 1
BCM_56450_B1 = 1
BCM_56640_A0 = 1
BCM_56850_A0 = 1
BCM_56340_A0 = 1
BCM_56150_A0 = 1
BCM_53400_A0 = 1
BCM_56960_A0 = 1
BCM_56160_A0 = 1
BCM_56860_A0 = 1
BCM_56560_A0 = 1
BCM_56260_A0 = 1
BCM_56260_B0 = 1
BCM_56270_A0 = 1
BCM_56560_B0 = 1
BCM_56965_A0 = 1
BCM_56970_A0 = 1
BCM_53570_A0 = 1
# }
endif
# }
endif

ifdef DNXF_CHIPS
CFGFLAGS += $(strip $(foreach chipname,$(DNXF_CHIP_NAMES), $(if $(value $(chipname)),,-DNO_$(chipname))))
endif # DNXF_CHIPS

ifdef SBX_CHIPS
# {
$(setallsbx)
ifndef BCM_FE2000_A0
# {
export NO_BCM_FE2000_A0 = 1
CFLAGS += -DNO_BCM_FE2000_A0
# }
endif
# }
endif

ifdef EA_CHIPS
# {
$(setallea)
ifndef BCM_TK371X_SUPPORT
# {
export BCM_TK371X_SUPPORT = 1
# }
endif
# }
endif

ifdef DPP_CHIPS
# {
$(setalldpp)
# }
endif

ifdef DFE_CHIPS
# {
$(setalldfe)
# }
endif

ifdef DNX_CHIPS
# {
$(setalldnx)
# }
endif

ifdef DNXF_CHIPS
# {
$(setalldnxf)
# }
endif

# }
else # BCM_PTL_SPT
# {

# Some chip or chips excluded

ifdef ROBO_CHIPS
# {
CFGFLAGS += $(strip $(foreach chipname,$(ROBO_CHIP_NAMES), $(if $(value $(chipname)),,-DNO_$(chipname))))
# }
endif # ROBO_CHIPS

ifdef ESW_CHIPS
# {
CFGFLAGS += $(strip $(foreach chipname,$(ESW_CHIP_NAMES), $(if $(value $(chipname)),,-DNO_$(chipname))))
CFGFLAGS += -DUSE_SCACHE_DIRTY_BIT
ifdef BCM_56340_A0
# {
BCM_56640_A0 = 1
# }
endif
ifdef BCM_56440_A0
# {
BCM_56840_A0 = 1
# }
endif
ifdef BCM_56440_B0
# {
BCM_56840_A0 = 1
# }
endif
ifdef BCM_56450_A0
# {
BCM_56840_A0 = 1
# }
endif
ifdef BCM_56450_B0
# {
BCM_56840_A0 = 1
# }
endif
ifdef BCM_56450_B1
# {
BCM_56840_A0 = 1
# }
endif
ifdef BCM_56260_A0
# {
BCM_56450_A0 = 1
BCM_56840_A0 = 1
# }
endif
ifdef BCM_56260_B0
# {
BCM_56450_A0 = 1
BCM_56840_A0 = 1
# }
endif
ifdef BCM_56270_A0
# {
BCM_56260_A0 = 1
BCM_56450_A0 = 1
BCM_56840_A0 = 1
# }
endif
ifdef BCM_56560_B0
# {
BCM_56560_A0 = 1
# }
endif
# }
endif # ESW_CHIPS

ifdef DPP_CHIPS
# {
CFGFLAGS += $(strip $(foreach chipname,$(DPP_CHIP_NAMES), $(if $(value $(chipname)),,-DNO_$(chipname))))
# }
endif # DPP_CHIPS

ifdef DFE_CHIPS
# {
CFGFLAGS += $(strip $(foreach chipname,$(DFE_CHIP_NAMES), $(if $(value $(chipname)),,-DNO_$(chipname))))
# }
endif # DFE_CHIPS

ifdef DNX_CHIPS
# {
CFGFLAGS += $(strip $(foreach chipname,$(DNX_CHIP_NAMES), $(if $(value $(chipname)),,-DNO_$(chipname))))
# }
endif # DNX_CHIPS

ifdef DNXF_CHIPS
# {
CFGFLAGS += $(strip $(foreach chipname,$(DNXF_CHIP_NAMES), $(if $(value $(chipname)),,-DNO_$(chipname))))
# }
endif # DNXF_CHIPS

ifdef SBX_CHIPS
# {
ifndef BCM_FE2000_A0
# {
export NO_BCM_FE2000_A0 = 1
CFLAGS += -DNO_BCM_FE2000_A0
# }
endif
CFGFLAGS += $(strip $(foreach chipname,$(SBX_CHIP_NAMES), $(if $(value $(chipname)),,-DNO_$(chipname))))
# }
endif # SBX_CHIPS

ifdef EA_CHIPS
# {
CFGFLAGS += $(strip $(foreach chipname,$(EA_CHIP_NAMES), $(if $(value $(chipname)),,-DNO_$(chipname))))
# }
endif # EA_CHIPS

# }
endif # BCM_PTL_SPT

ifndef	FEATURE_LIST
# {
ifdef ROBO_CHIPS
# {
ifeq "$(HOSTTYPE)" "Windows2000PC"
# {
_ROBO_FEATURE_LIST = L3 I2C BCMX BCMX_DIAG EDITLINE TEST CINT
# }
else
# {
_ROBO_FEATURE_LIST = L3 I2C BCMX BCMX_DIAG EDITLINE TEST CINT
# }
endif
# }
endif

ifdef ESW_CHIPS
# {
_ESW_FEATURE_LIST = L3 I2C BCMX BCMX_DIAG MEM_SCAN EDITLINE RCPU OOB_RCPU CUSTOMER \
    TEST CHASSIS CINT PTP BFD TCB PSTATS
#
# CES is only supported on Katana devices.
#
ifdef BCM_56440_A0 
# {
_ESW_FEATURE_LIST += CES
# }
endif
ifdef BCM_56440_B0 
# {
_ESW_FEATURE_LIST += CES
# }
endif
# }
endif

ifdef SBX_CHIPS
# {
_SBX_FEATURE_LIST = L3 BCMX BCMX_DIAG EDITLINE CUSTOMER TEST CHASSIS CINT
ifdef BCM_88030_A0
# {
	_SBX_FEATURE_LIST += I2C
# }
endif
ifdef BCM_88030_A1
# {
	_SBX_FEATURE_LIST += I2C
# }
endif
ifdef BCM_88030_B0
# {
	_SBX_FEATURE_LIST += I2C
# }
endif
# }
endif

ifdef EA_CHIPS        
# {
_EA_FEATURE_LIST = EDITLINE CUSTOMER TEST CINT 
ifdef BCM_TK371X_SUPPORT
# {
ifdef ROBO_CHIPS
# {
_EA_FEATURE_LIST += FIELD KNET
# }
endif
# }
endif 
# }
endif

ifdef DPP_CHIPS
# {
_DPP_FEATURE_LIST = L3 EDITLINE CUSTOMER TEST CHASSIS CINT BFD
# }
endif

ifdef DFE_CHIPS
# {
_DFE_FEATURE_LIST = L3 EDITLINE CUSTOMER TEST CHASSIS CINT
# }
endif

ifdef DNX_CHIPS
# {
_DNX_FEATURE_LIST = L3 EDITLINE CUSTOMER TEST CHASSIS CINT BFD
# }
endif

ifdef DNXF_CHIPS
# {
_DNXF_FEATURE_LIST = L3 EDITLINE CUSTOMER TEST CHASSIS CINT
# }
endif

_ALL_FEATURE_LIST = ${_ROBO_FEATURE_LIST} ${_ESW_FEATURE_LIST} \
		${_SBX_FEATURE_LIST} ${_EA_FEATURE_LIST} ${_DPP_FEATURE_LIST} \
		${_DFE_FEATURE_LIST} ${_DNX_FEATURE_LIST} ${_DNXF_FEATURE_LIST}

FEATURE_LIST = $(sort ${_ALL_FEATURE_LIST})

ifeq ($(targetbase),vxworks)
# {
FEATURE_LIST +=	TELNET
FEATURE_LIST += DRIVERS
# }
endif


# end ifndef FEATURE_LIST
# }
endif

# Include board make rules if present
-include ${SDK}/make/Make.boards

ifdef ROBO_CHIPS
# {
FEATURE_LIST += MSTP
# }
endif

# If TCL is enabled then add EDITLINE and ASE_TEST
ifeq (TCL,$(findstring TCL,$(FEATURE_LIST)))
# {
ifneq (EDITLINE,$(findstring EDITLINE,$(FEATURE_LIST)))
# {
FEATURE_LIST += EDITLINE
# }
endif

ifneq (ASE_TEST,$(findstring ASE_TEST,$(FEATURE_LIST)))
# {
FEATURE_LIST += ASE_TEST
# }
endif
# }
endif

# DPP only compiles with BFD
ifdef DPP_CHIPS
# {
ifneq (BFD,$(findstring BFD,$(FEATURE_LIST)))
# {
FEATURE_LIST += BFD
# }
endif
# Uncomment the next three lines to force PTP inclusion for DPP chipsets
#ifneq (PTP,$(findstring PTP,$(FEATURE_LIST)))
#FEATURE_LIST += PTP
#endif
# }
endif

# DNX only compiles with BFD
ifdef DNX_CHIPS
# {
ifneq (BFD,$(findstring BFD,$(FEATURE_LIST)))
# {
FEATURE_LIST += BFD
# }
endif
# Uncomment the next three lines to force PTP inclusion for DNX chipsets
#ifneq (PTP,$(findstring PTP,$(FEATURE_LIST)))
#FEATURE_LIST += PTP
#endif
# }
endif

# If BFD is enabled then add L3
ifeq (BFD,$(findstring BFD,$(FEATURE_LIST)))
# {
ifneq (L3,$(findstring L3,$(FEATURE_LIST)))
# {
FEATURE_LIST += L3
# }
endif
# }
endif

# If CINT is not enabled, filter out APIMODE
ifeq (,$(findstring CINT,$(FEATURE_LIST)))
# {
FEATURE_EXCLUDE_LIST += APIMODE
# }
endif

ifdef NO_SAL_APPL
# {
FEATURE_EXCLUDE_LIST += TCL EDITLINE I2C TELNET DRIVERS CINT APIMODE
CFGFLAGS += -DNO_SAL_APPL -DNO_CTRL_C -DNO_FILEIO -DNO_MEMTUNE
# }
endif


ifdef FEATURE_EXCLUDE_LIST
# {
FEATURE_LIST := $(filter-out $(FEATURE_EXCLUDE_LIST), $(FEATURE_LIST))
# }
endif

# If L3 is not defined, remove MPLS_LM_DM if present.
ifeq (MPLS_LM_DM,$(findstring MPLS_LM_DM,$(FEATURE_LIST)))
# {
ifneq (L3,$(findstring L3,$(FEATURE_LIST)))
# {
FEATURE_LIST := $(filter-out MPLS_LM_DM, $(FEATURE_LIST))
# }
endif
# }
endif

CFGFLAGS += $(foreach feature,$(FEATURE_LIST), -DINCLUDE_$(feature))

ifeq (IPSEC,$(findstring IPSEC,$(FEATURE_LIST)))
DIAG_IPSEC=1
endif

#
# Robo5324 support MDC/MDIO.
#
ifdef ROBO_CHIPS
# {
ifndef ROBO_OLD
# {
CFGFLAGS += -DEBBUS_BIT16
# }
endif

ifdef BCM_89500_A0
# {
ifeq (WR_LINUX,$(BUILD_PLATFORM))
# {
ifeq (3.0,$(WRS_LINUX_VERSION))
# {
ifeq (unix-user,$(target))
# {
CFGFLAGS += -DINCLUDE_APS_DIAG_LIBS
# }
endif
# }
endif
# }
endif

ifeq ($(targetbase), vxworks)
# {
ifeq ($(targetplat), keystone)
# {
CFGFLAGS += -DINCLUDE_APS_DIAG_LIBS
# }
endif
# }
endif

# }
endif

# }
endif

ifneq ($(targetbase),vxworks)
# {
# Make sure that VX_VERSION doesn't indicate VX_WORKS even if set
VX_VERSION = ''
# }
endif


ifdef SBX_CHIPS
# {
CFGFLAGS += -DCHECK_BUILD -DZDT_SIM -DSB_FAB_LOG_WITH_BCM

ifdef BCM_FE2000_A0
# {
# Microcode options: Default microcode is G2P2; all supported
# microcodes are compiled in by default
# CFGFLAGS += -DBCM_FE2000_P2_SUPPORT=0
CFGFLAGS += -DBCM_FE2000_P3_SUPPORT=1
CFGFLAGS += -DBCM_FE2000_G2XX_SUPPORT=1
# BCM_FE2000_P2=0
BCM_FE2000_P3=1
BCM_FE2000_G2XX=1
# }
endif

ifdef BCM_88030_A0
# {
#Caladan3 g3p1 support
CFGFLAGS += -DBCM_CALADAN3_G3P1_SUPPORT
CFGFLAGS += -DBCM_CALADAN3_T3P1_SUPPORT

ifndef PCID_BUILD
# {
#Caladan3 SVK support
CFGFLAGS += -DBCM_CALADAN3_SVK
# }
else
# {
#Sim support for PCID Builds
CFGFLAGS += -DBCM_CALADAN3_SIM
# }
endif

# }
endif

# }
endif

ifndef	DISPATCH_LIST
# {
ifdef ROBO_CHIPS
# {
DISPATCH_LIST =	ROBO
# }
endif
ifdef ESW_CHIPS
# {
DISPATCH_LIST += RPC ESW
# }
endif
ifdef SBX_CHIPS
# {
DISPATCH_LIST += RPC SBX
ifdef BCM_88030_A0
# {
DISPATCH_LIST += CALADAN3
# }
endif
# }
endif

ifdef BCM_EA_SUPPORT
# {
CFGFLAGS += -DBCM_EA_SUPPORT
ifdef BCM_TK371X_SUPPORT
# {
DISPATCH_LIST += TK371X
# }
endif

# }
endif

# }
endif
ifdef BCM_88732_A0
# {
DISPATCH_LIST += SHADOW
# }
endif

#
# SAND_CHIPS means that at least one of Dune chip family defined
# aka DPP_CHIPS || DFE_CHIPS || DNX_CHIPS || DNXF_CHIPS
#
# If ANY 'dune chip' is supported (SAND_CHIPS = 1) then define
# BCM_SAND_SUPPORT (for C-preprocessor usage) to indicate that.
#

ifdef DPP_CHIPS
# {
DISPATCH_LIST += RPC PETRA
SAND_CHIPS = 1
# }
endif
ifdef DFE_CHIPS
# {
DISPATCH_LIST += RPC DFE
SAND_CHIPS = 1
# }
endif
#
# For 'dnx', we want only DNX
# See dispatcher.c
#
ifdef DNX_CHIPS
# {
DISPATCH_LIST += RPC DNX
SAND_CHIPS = 1
# }
endif

ifdef DNXF_CHIPS
# {
DISPATCH_LIST += RPC DNXF
SAND_CHIPS = 1
# }
endif

#
# If ANY 'dune chip' is supported then define BCM_SAND_SUPPORT to
# indicate that.
#
ifdef SAND_CHIPS
# {
CFGFLAGS += -DBCM_SAND_SUPPORT
# }
endif

CFGFLAGS += $(foreach dispatch,$(DISPATCH_LIST), -DBCM_$(dispatch)_SUPPORT)
ifneq (,$(findstring -DBCM_RPC_SUPPORT,$(CFGFLAGS)))
# {
CFGFLAGS += -DINCLUDE_LIB_CPUDB
CFGFLAGS += -DINCLUDE_LIB_CPUTRANS
CFGFLAGS += -DINCLUDE_LIB_DISCOVER
CFGFLAGS += -DINCLUDE_LIB_STKTASK
CFGFLAGS += -DDISCOVER_APP_DATA_BOARDID
# }
endif

ifdef DPP_CHIPS
# {
CFLAGS += -DDUNE_BCM -DLINK_PETRA_LIBRARIES -DLINK_PPD_LIBRARIES
ifdef BCM_88675_A0
# {
CFLAGS += -DBCM_JERICHO_SUPPORT
# }
endif
ifdef BCM_88375_A0
# {
CFLAGS += -DBCM_JERICHO_SUPPORT
# }
endif
ifdef BCM_88680_A0
# {
CFLAGS += -DBCM_JERICHO_PLUS_SUPPORT
# }
endif
ifdef BCM_88470_A0
# {
CFLAGS += -DBCM_QAX_SUPPORT
# }
endif
ifdef BCM_88270_A0
# {
CFLAGS += -DBCM_QUX_SUPPORT
# }
endif
ifdef BCM_8206_A0
# {
CFLAGS += -DBCM_FLAIR_SUPPORT
# }
endif
ifneq (,$(findstring -DPLISIM,$(CFLAGS)))
# {
CFLAGS += -DSAND_LOW_LEVEL_SIMULATION -DUSING_CHIP_SIM
DEBUG_SYMBOLS=TRUE
# }
endif
ifneq (, $(findstring PIONEER,$(FEATURE_LIST)))
# {
CFGFLAGS += -DINCLUDE_LIB_PIONEER_HOST  
# }
endif
# }
endif

ifdef DNX_CHIPS
# {
ifdef BCM_88690_A0
# {
CFLAGS += -DBCM_JERICHO_2_SUPPORT
# }
endif
ifneq (,$(findstring -DPLISIM,$(CFLAGS)))
# {
CFLAGS += -DSAND_LOW_LEVEL_SIMULATION -DUSING_CHIP_SIM
DEBUG_SYMBOLS=TRUE
# }
endif
ifneq (, $(findstring PIONEER,$(FEATURE_LIST)))
# {
CFGFLAGS += -DINCLUDE_LIB_PIONEER_HOST  
# }
endif
# }
endif

ifdef DFE_CHIPS
# {
CFLAGS += -DDUNE_BCM
ifneq (,$(findstring -DPLISIM,$(CFLAGS)))
# {
CFLAGS += -DSAND_LOW_LEVEL_SIMULATION -DUSING_CHIP_SIM
DEBUG_SYMBOLS=TRUE
# }
endif
# }
endif

ifdef DNXF_CHIPS
# {
ifneq (,$(findstring -DPLISIM,$(CFLAGS)))
# {
CFLAGS += -DSAND_LOW_LEVEL_SIMULATION -DUSING_CHIP_SIM
DEBUG_SYMBOLS=TRUE
# }
endif
# }
endif

ifneq (,$(findstring I2C,$(FEATURE_LIST)))
# {
CFGFLAGS += -DINCLUDE_I2C
# }
endif

ifneq (,$(findstring AEDEV,$(FEATURE_LIST)))
# {
CFGFLAGS += -DINCLUDE_LIB_AEDEV
# }
endif

ifneq (,$(findstring CINT,$(FEATURE_LIST)))
# {
CFGFLAGS += -DINCLUDE_LIB_CINT
CFGFLAGS += -DCINT_CONFIG_INCLUDE_SDK_SAL=1 -DCINT_CONFIG_INCLUDE_PARSER=1 -DCINT_CONFIG_INCLUDE_CINT_LOAD=0
ifeq (,$(findstring EDITLINE,$(FEATURE_LIST)))
# {
CFGFLAGS += -DCINT_CONFIG_INCLUDE_PARSER_READLINE=0 -DCINT_CONFIG_INCLUDE_PARSER_ADD_HISTORY=0
# }
endif
# }
endif

ifneq (,$(findstring C_UNIT,$(FEATURE_LIST)))
# {
CFGFLAGS += -DINCLUDE_LIB_C_UNIT
CFGFLAGS += -DC_UNIT_CONFIG_INCLUDE_SDK_SAL=1
# }
endif

ifndef	VENDOR_LIST
# {
VENDOR_LIST =	CALHOUN GAMMA BROADCOM
# }
endif
CFGFLAGS += $(foreach vendor,$(VENDOR_LIST), -DVENDOR_$(vendor))

ifndef	BCM_PHY_LIST
# {
BCM_PHY_LIST=522X 54XX 5464 5421S 5482 54616 54680 54680E 52681E 54880E 54682 54684 54640 54640E 54880 SERDES SIMUL 8703 8705 8706 8072 8040 8481 8750 8729 84740 84756 54380 542XX 84334 84728 84749 84328 84793 82328 82381 82780
BCM_PHY_LIST += 82764 EGPHY28 82864 82109
ifdef ESW_CHIPS
# {
BCM_PHY_LIST += 8806X
# }
endif
# }
endif

CFGFLAGS += $(foreach phy,$(BCM_PHY_LIST), -DINCLUDE_PHY_$(phy))

ifneq (,(findstring 54880,$(BCM_PHY_LIST)))
# {
CFGFLAGS += -DINCLUDE_LONGREACH
# }
endif

# use QUIET=1 to control printing of compilation lines
ifdef	QUIET
# {
Q:=@
# }
else
# {
Q:=
# }
endif

#
# Suffix to add to the "target" files to allow local builds with different
# flags. Set "target_suffix" to XXX to cause the build to put built objects
# in ${target}${target_suffix}. This allows things like building a debug
# version with different flags.  This may also be set in another Makefile.
#

#target_suffix :=

#
# Optional suffix to add to the build directory and output binary files
# to allow multiple builds to co-exist for various reasons.
#
#chip_suffix := -$(shell echo $(CHIP) | tr A-Z a-z)

#
# Combined suffixes
#
all_suffix = ${chip_suffix}${target_suffix}

#
# Default location to place binaries and make depend files for building
# purposes.
#
ifeq "$(HOSTTYPE)" "Windows2000PC"
# {
BLDROOTWITHDRIVE = ${SDK}/build/${target}${all_suffix}${bldroot_suffix}
BLDROOT = ${SDK_NO_DRIVE_NAME}/build/${target}${all_suffix}${bldroot_suffix}
# }
else # ifeq "$(HOSTTYPE)" "Windows2000PC"
# {

ifndef SDKBUILD
# {
SDKBUILD :=build
# }
endif

BLDROOT = ${SDK}/${SDKBUILD}/$(if ${BLDCONFIG},${BLDCONFIG}/)${target}${all_suffix}${bldroot_suffix}

# }
endif # ifeq "$(HOSTTYPE)" "Windows2000PC"

# This is needed because we cannot include Make.vxworks before Make.config
ifndef DEST_DIR_SUFFIX
# {
export DEST_DIR_SUFFIX :=$(subst $(realpath $(SDK))/systems,,$(realpath $(CURDIR)/$(dir ($(firstword $(MAKEFILE_LIST))))))
ifeq ($(MAKELEVEL),0)
# {
# }
endif
# }
endif

ifeq ($(DEST_DIR),)
# {
export DEST_DIR :=${SDK}/${SDKBUILD}$(if ${BLDCONFIG},/${BLDCONFIG})$(DEST_DIR_SUFFIX)
# }
endif

ifdef LOCALDIR
# {
BLDDIR = ${BLDROOT}/${LOCALDIR}
ifeq "$(HOSTTYPE)" "Windows2000PC"
# {
BLDDIRWITHDRIVE = ${BLDROOTWITHDRIVE}/${LOCALDIR}
# }
endif
# }
else # ifdef LOCALDIR
# {
BLDDIR = ${BLDROOT}
ifeq "$(HOSTTYPE)" "Windows2000PC"
# {
BLDDIRWITHDRIVE = ${BLDROOTWITHDRIVE}
# }
endif
# }
endif # ifdef LOCALDIR

LIBDIR = ${BLDROOT}

#
# Export directory, where build objects used by the outside world are
# placed (exported header files, libs, bins)
#
EXPDIR = ${SDK}/export/${target}${all_suffix}

#
# Standard include paths
#

INCDIR	= ${SDK}/include
ifdef ROBO_CHIPS
# {
INCDIR += -I$(SDK)/include/soc/robo -I$(SDK)/include/bcm_int/robo \
	-I$(SDK)/src/soc/robo
# }
endif

ifdef EA_CHIPS
# {
INCDIR += -I$(SDK)/include/soc/ea -I$(SDK)/include/bcm_int/ea
# }
endif

ifdef SBX_CHIPS
# {
ifndef NO_BCM_FE2000_A0
# {
INCDIR += \
	-I${SDK}/include/soc/sbx/g2eplib \
       -I${SDK}/include/soc/sbx/qe2k \
       -I${SDK}/include/soc/sbx/qe2kep \
       -I${SDK}/include/soc/sbx \
       -I${SDK}/include/soc/sbx/fabric
# }
else
# {
INCDIR += \
       -I${SDK}/include/soc/sbx/g2eplib \
       -I${SDK}/include/soc/sbx/qe2k \
       -I${SDK}/include/soc/sbx/qe2kep \
       -I${SDK}/include/soc/sbx \
       -I${SDK}/include/soc/sbx/fabric
# }
endif

ifdef BCM_88030_A0
# {
INCDIR += -I${SDK}/include/soc/sbx/caladan3
INCDIR += -I${SDK}/include/soc/sbx/caladan3/tmu
INCDIR += -I${SDK}/include/soc/sbx/caladan3/asm3
# }
endif

# }
endif

# MACSEC include paths
ifneq (,$(findstring MACSEC,$(FEATURE_LIST)))
# {
BUILD_MACSEC = 1
FEATURE_MACSEC = 1
MACSEC_BUILD_FLAG=-DBROADCOM_SAL -I${SDK} -I${SDK}/include -g -Wall -Werror -fno-strict-aliasing

MACSEC_BUILD_FLAG += ${STD_CFLAGS}

ifndef MACSEC_HOME
# {
toast:; $(error 'The $$MACSEC_HOME environment variable is not set')
# }
endif
INCDIR += -I${SDK} -I${MACSEC_HOME}/include -I${MACSEC_HOME}/cli -I${MACSEC_HOME}/phy/bcm54380  -I${MACSEC_HOME}/phy/bcm8729 -I${MACSEC_HOME}/phy/bcm84756 -I${MACSEC_HOME}/phy/bcm84334  -I${MACSEC_HOME}/phy/bcm84749  -I${MACSEC_HOME}/phy/dummyphy
CFGFLAGS += -DBROADCOM_SAL
# }
endif

# FCMAP include paths
ifneq (,$(findstring FCMAP,$(FEATURE_LIST)))
# {
FEATURE_FCMAP = 1
INCDIR += -I${SDK}  -I${SDK}/include -I${SDK}/src/soc/phy/fcmap/include
CFGFLAGS += -DBROADCOM_SAL
# }
endif
INCDIR += -I${SDK}  -I${SDK}/include -I${SDK}/src/soc/phy/chip/koi/merlin_koi_src
INCDIR += -I${SDK}  -I${SDK}/include -I${SDK}/src/soc/phy/chip/orca/eagle_orca_src

ifdef IMACSEC_HOME
INCDIR += -I${SDK}/src/soc/phy -I${SDK}/src/soc/phy/imacsec/include -I${IMACSEC_HOME}/bcm_plp_base_t_sec
CFGFLAGS += -DINCLUDE_PLP_IMACSEC
CFGFLAGS += -DINCLUDE_PLP_UNIMAC
endif

# EAV APPL in diag is intended to be built
#ifneq (,$(findstring EAV_APPL,$(FEATURE_LIST)))
#BUILD_EAV_APPL = 1
#endif

ifneq (,$(findstring KNET,$(FEATURE_LIST)))
# {
BUILD_KNET = 1
ifdef KS_BUILD
# {
BUILD_ROBO_KNET = 1
# }
endif 
ifdef IPROC_BUILD
# {
ifdef ROBO_CHIPS
# {
BUILD_ROBO_KNET = 1
# }
endif
# }
endif
# }
endif

# Start Checking for KBP feature
#
ifeq (KBP,$(findstring KBP,$(FEATURE_LIST)))
# {
ifndef KBP_DEVICE
# {
$(error "KBP Feature is Enabled, and no valid Device was defined. Define KBP_DEVICE=KBP_11K or KBP_DEVICE=KBP_ALG")
# }
else
# {
ifeq (KBP_12K,$(findstring KBP_12K,$(KBP_DEVICE)))
# {
$(error "KBP_12K device not supported. Only KBP_11K and KBP_ALG devices are supported for KBP feature")
# }
endif
# }
endif

ifeq (KBP_11K,$(findstring KBP_11K,$(KBP_DEVICE)))
# {
DEVICE=nlm2
INCDIR += -I${SDK}/include/soc/kbp/nlm2/diagnostic
INCDIR += -I${SDK}/include/soc/kbp/nlm2/nlmxpt
INCDIR += -I${SDK}/include/soc/kbp/nlm2/simxpt
# }
endif

ifeq (KBP_12K,$(findstring KBP_12K,$(KBP_DEVICE)))
# {
DEVICE=nlm3
INCDIR += -I${SDK}/include/soc/kbp/nlm3/model
INCDIR += -I${SDK}/include/soc/kbp/nlm3/blackholexpt
INCDIR += -I${SDK}/include/soc/kbp/nlm3/xpt
# }
endif

ifneq (KBP_ALG,$(findstring KBP_ALG,$(KBP_DEVICE)))
# {
KBP_LIBDIR=${SDK}/src/soc/kbp/${DEVICE}/lib/${targetbase}-${targetplat}/${platform}/

CFLAGS += -DNLMPLATFORM_BCM
INCDIR += -I${SDK}/include
INCDIR += -I${SDK}/include/soc/kbp/${DEVICE}/nlmdevmgr
INCDIR += -I${SDK}/include/soc/kbp/${DEVICE}/arch
INCDIR += -I${SDK}/include/soc/kbp/common
INCDIR += -I${SDK}/include/soc/kbp/${DEVICE}/nlmrangemgr
INCDIR += -I${SDK}/include/soc/kbp/${DEVICE}/nlmgenerictblmgr
INCDIR += -I${SDK}/include/soc/kbp/${DEVICE}/nlmfibtblmgr/api
INCDIR += -I${SDK}/include/soc/kbp/${DEVICE}/nlmfibtblmgr/common
# }
else
# {
INCDIR += -I${SDK}/include/soc/kbp/alg_kbp/include
CFLAGS += -DNLMPLATFORM_UNIX -DNLMPLATFORM_LINUX
# }
endif


ifeq ($(shell uname -m),x86_64)
# {
ifeq (DLONGS_ARE_64BITS,$(findstring DLONGS_ARE_64BITS,$(CFLAGS)))
# {
ifeq (DPTRS_ARE_64BITS,$(findstring DPTRS_ARE_64BITS,$(CFLAGS)))
# {
CFLAGS += -DNLM_BUILD64
# }
endif
# }
endif
# }
endif
# }
endif

# End Checking for KBP feature

#
# PHYMOD library support
#
# PHYMOD_CHIP_NAMES defines which internal PHYs require PHYMOD support.
# PHYMOD_PHY_LIST defines which external PHYs require PHYMOD support.
#
PHYMOD_CHIP_NAMES = BCM_53400_A0 BCM_88650_A0 BCM_88950_A0 BCM_88790_A0 BCM_88675_A0 BCM_56860_A0 BCM_88375_A0 BCM_88680_A0 BCM_88690_A0  BCM_88470_A0   BCM_88270_A0 BCM_8206_A0 BCM_56960_A0 BCM_88202_A0 BCM_56560_A0 BCM_56560_B0 BCM_56260_A0 BCM_56160_A0 BCM_56260_B0 BCM_56965_A0 BCM_56970_A0 BCM_53570_A0

PHYMOD_PHY_LIST = 82381 82764 8806X 82864 82109

# Define default PHYMOD support based on included PHYs
ifeq (,$(PHYMOD_SUPPORT))
# {
seekphymodchips = $(foreach chipname,$(PHYMOD_CHIP_NAMES),$(whereischip))
ifneq "$(findstring file,$(seekphymodchips))" ""
# {
PHYMOD_SUPPORT = 1
# }
endif
# }
endif
ifeq (,$(PHYMOD_SUPPORT))
# {
ifneq (,$(filter $(PHYMOD_PHY_LIST),$(BCM_PHY_LIST)))
# {
PHYMOD_SUPPORT = 1
# }
endif
# }
endif

# Include PHYMOD diagnotics by default
ifeq (,$(PHYMOD_DIAG))
# {
PHYMOD_DIAG = $(PHYMOD_SUPPORT)
# }
endif

# Configure PHYMOD build
ifeq (1,$(PHYMOD_SUPPORT))
# {
BUILD_PHYMOD = 1
INCDIR += -I${SDK}/libs/phymod/include
CFLAGS += -DPHYMOD_SUPPORT
CFLAGS += -DPHYMOD_TIER1_SUPPORT
CFLAGS += -DPHYMOD_INCLUDE_CUSTOM_CONFIG
ifeq (1,$(PHYMOD_DIAG))
# {
CFLAGS += -DPHYMOD_DIAG
# }
endif
# }
endif

PORTMOD_CHIP_NAMES = BCM_53400_A0 BCM_88950_A0 BCM_88790_A0 BCM_88670_A0 BCM_88675_A0 BCM_56860_A0 BCM_88375_A0  BCM_88680_A0 BCM_88690_A0 BCM_88470_A0  BCM_88270_A0 BCM_8206_A0 BCM_56960_A0 BCM_56560_A0 BCM_56560_B0 BCM_56160_A0 BCM_56965_A0 BCM_56970_A0 BCM_53570_A0

seekportmod =  $(foreach chipname,$(PORTMOD_CHIP_NAMES),$(whereischip))
#portmod support)
ifeq (,$(PORTMOD_SUPPORT))
# {
ifneq "$(findstring file,$(seekportmod))" ""
# {
PORTMOD_SUPPORT = 1
# }
endif
# }
endif

ifeq (1,$(PORTMOD_SUPPORT))
# {
BUILD_PORTMOD = 1
CFLAGS += -DPORTMOD_DIAG
CFLAGS += -DPORTMOD_SUPPORT
export PORTMOD_SUPPORT
# }
endif

#Add the devices that supports SW Autoneg to the lst below 
SW_AN_CHIP_NAMES = BCM_56965_A0 BCM_56560_B0 BCM_56565_B0 BCM_56969_A0 BCM_56966_A0 BCM_56967_A0

ifeq (,$(SW_AUTONEG_SUPPORT))
# {
seekswanchips = $(foreach chipname,$(SW_AN_CHIP_NAMES),$(whereischip))
ifneq "$(findstring file,$(seekswanchips))" ""
# {
SW_AUTONEG_SUPPORT = 1
# }
endif
# }
endif

ifeq (1,$(SW_AUTONEG_SUPPORT))
# {
CFLAGS += -DSW_AUTONEG_SUPPORT
#}
endif



#
# Paths of where we install files for make install
#
# install_headers - where to install header files.
# install_lib     - where to install libs
# install_bin	  - where to install completely linked binaries
#
install_headers	= ${SDK}/export/include
install_lib	= ${SDK}/export/lib/${target}
install_bin	= ${SDK}/export/bin/${target}

#
# Compilation Flags
#
# Flags may be added to (see below)
#

INCDIR += -I${SDK}/src/soc/phy/phy8806x/include

INCFLAGS = -I${INCDIR} -I${SDK}/systems

CFLAGS += ${INCFLAGS}
CXXFLAGS += ${INCFLAGS}
CPPFLAGS += ${INCFLAGS}

#
# Debug #ifdef control
#
# Compiling out #ifdef DEBUG code saves about 1.3% on executable size.
# It is recommended to leave debug enabled when developing applications.
#
ifndef DEBUG_IFDEFS
# {
DEBUG_IFDEFS=TRUE
# }
endif

ifeq ($(DEBUG_IFDEFS),TRUE)
# {
CFLAGS += -DBROADCOM_DEBUG
CXXFLAGS += -DBROADCOM_DEBUG
CPPFLAGS += -DBROADCOM_DEBUG
# }
endif

#
# Debug symbol information control
#
ifneq ($(targetbase),ghs)
# {
ifndef DEBUG_SYMBOLS
# {
DEBUG_SYMBOLS=TRUE
# }
endif
# }
endif

ifeq ($(DEBUG_SYMBOLS),TRUE)
# {
CFLAGS += -g
CXXFLAGS += -g
CPPFLAGS += -g
# }
endif

ifndef BCM_88732_A0
# {
CFGFLAGS += -DNO_BCM_88732_A0
# }
endif

#
# If DEBUG_CFLAGS is set, add its contents to CFLAGS.
# May be useful for setting on the command line or adding to Make.local.
# Example: gmake DEBUG_CFLAGS=-save-temps system.c
#

ifneq ($(DEBUG_CFLAGS),)
# {
CFLAGS += $(DEBUG_CFLAGS)
CXXFLAGS += $(DEBUG_CFLAGS)
CPPFLAGS += $(DEBUG_CFLAGS)
# }
endif

#
# Optimization level
#
# Set DEBUG_OPTIMIZE to TRUE (default) to use a normal optimization
#		determined by OPTFLAGS_DEFAULT in the platform Makefile.
# Set DEBUG_OPTIMIZE to FALSE to use no optimization,
#		strongly recommended when using any debugger.
# Set DEBUG_OPTIMIZE to any other option string to request specific
#		optimization flags (for example -O2).
#
ifndef DEBUG_OPTIMIZE
# {
DEBUG_OPTIMIZE=TRUE
# }
endif

ifeq ($(DEBUG_OPTIMIZE),TRUE)
# {
OPTFLAGS += $(OPTFLAGS_DEFAULT)
# }
else
# {
ifneq ($(DEBUG_OPTIMIZE),FALSE)
# {
OPTFLAGS += $(DEBUG_OPTIMIZE)
# }
endif
# }
endif

#
# Debug assertion control.
#
# Compiling out assert() saves about 1.1% on executable size,
# however doing so is VERY MUCH discouraged.
#
ifndef DEBUG_ASSERTS
# {
DEBUG_ASSERTS=TRUE
# }
endif

ifeq ($(DEBUG_ASSERTS),FALSE)
# {
CFLAGS += -DNDEBUG
CXXFLAGS += -DNDEBUG
CPPFLAGS += -DNDEBUG
# }
endif

#
# GCC pedantic mode.
#
ifeq ($(DEBUG_PEDANTIC),TRUE)
# {
CFGFLAGS += -D__PEDANTIC__
CFLAGS += --pedantic
CXXFLAGS += --pedantic
# }
endif

#
# In each directory, build a list of local sources, objects, and headers
#
LSRCS	=	$(wildcard *.c *.cpp *.s *.cc *.C)
LOBJS	=	$(addsuffix .o, $(basename ${LSRCS}))
BOBJS	= 	$(addprefix ${BLDDIR}/,${LOBJS})
LHDRS	=	$(wildcard *.h *.H)
LDOTIS	=	$(wildcard *.i)


ifeq ($(TOOLS),Borland)
# {
BORLAND_LOBJS	=	$(addsuffix .obj, $(basename ${LSRCS}))
#BORLAND_BLDDIR	= 	$(subst, \,/, $(subst -,_,$(BLDDIR)))
BORLAND_BLDDIR	= 	$(BLDDIR)
BORLAND_BOBJS	= 	$(addprefix ${BORLAND_BLDDIR}/,${BORLAND_LOBJS})
# }
endif

#
# Rule to create object file (build) directory
#

.PHONY: all install clean distclean

.PRECIOUS: ${BLDDIR}/.tree

%/.tree:
	@$(ECHO) Creating build directory $(dir $@)
	$Q($(MKDIR) $(dir $@); $(TOUCH) $@)

# Rule allowing build through CPP only, creates .E file from .c file.

%.E: %.c
	$Q$(CC) -E ${CFLAGS} $< | $(SED) -e '/^ *$$/d' -e p -e d > $@

# Rule allowing build through source only, creates .s file from .c file.

%.s: %.c
	$Q$(CC) -S ${CFLAGS} $<

# allow disabling of dependency file generation
# enable partial recompilation through use of included
# dependency make files
#
ifndef NO_SDK_DEPS
# {
# take the compiler generated .d file and reparse it 
# to generate a dependency graph rule for this object
# file
# the two steps generate:
#  file.o: file.c \
#	file.h ...
#
#  file.h: 
#  header.h: 
# some compilers will generate errors without the latter
# part of the list

.PHONY: .phony

DEPS_SED = \
	$(CP) $(BLDDIR)/$*.d $(BLDDIR)/$*.tmp;\
	$(ECHO) >> $(BLDDIR)/$*.tmp;\
	$(SED) -e 's/\#.*//' -e 's/^[^:]*: *//' \
	-e 's/ *\\$$//' -e '/^$$/ d' -e 's/$$/ :/' \
	-e '/^ .$$/d' \
	< $(BLDDIR)/$*.d >> $(BLDDIR)/$*.tmp; \
	$(SED) -e 's|^\([^\/ ].*\.o\):|'$(BLDDIR)/'\1:|g'  \
	-e 's|.*?/\(.*\.o\):|'$(BLDDIR)/'\1:|g'  \
	< $(BLDDIR)/$*.tmp > $(BLDDIR)/$*.P; \
	$(RM) -f $(BLDDIR)/$*.d $(BLDDIR)/$*.tmp
DEPS_CMD = $(DEPS_SED)

ifeq ($(targetbase),ghs)
# {
DEPS_CMD = $(DEPS_SED)
# }
else
# {
ifeq ($(VX_VERSION),55)
# {
# this supports the tornado 2.x.x compiler
# (VxWorks 5.x)
DEPS_CMD = $(DEPS_SED)
# }
else
# {
ifneq ($(findstring gnu,$(TOOL)),)
# {
# Gnu compilers always support -MD -MF
DEPS_OPT = -MD -MF $(BLDDIR)/$*.d
DEPS_CMD = $(DEPS_SED)
# }
else
# {
ifneq (,$(filter 64 65,$(VX_VERSION)))
# {
BCM_CFLAGS = -Xstop-on-warning -Xlint
DEPS_OPT = -Xmake-dependency=4 -Xmake-dependency-savefile=$(BLDDIR)/$*.d
DEPS_CMD = $(DEPS_SED)
# }
else
# {
ifneq ($(findstring i686,$(CROSS_COMPILE)),)
# {
# Gcc 2.95 does not support -MD -MF with -o and -c
# }
else
# {
# newer gnu-based compilers allow -MD -MF
DEPS_OPT = -MD -MF $(BLDDIR)/$*.d
DEPS_CMD = $(DEPS_SED)
# }
endif
# }
endif
# }
endif
# }
endif
# }
endif

# From gmsl

# Standard definitions for true and false.  true is any non-empty
# string, false is an empty string. These are intended for use with
# $(if).

true  := T
false :=

# ----------------------------------------------------------------------------
# Function:  not
# Arguments: 1: A boolean value
# Returns:   Returns the opposite of the arg. (true -> false, false -> true)
# ----------------------------------------------------------------------------
not = $(if $1,$(false),$(true))

# ----------------------------------------------------------------------------
# Function:  map
# Arguments: 1: Name of function to $(call) for each element of list
#            2: List to iterate over calling the function in 1
# Returns:   The list after calling the function on each element
# ----------------------------------------------------------------------------
map = $(strip $(foreach a,$2,$(call $1,$a)))

# ----------------------------------------------------------------------------
# Function:  seq
# Arguments: 1: A string to compare against...
#            2: ...this string
# Returns:   Returns $(true) if the two strings are identical
# ----------------------------------------------------------------------------
seq = $(if $(filter-out xx,x$(subst $1,,$2)$(subst $2,,$1)x),$(false),$(true))

# ----------------------------------------------------------------------------
# Function:  sne
# Arguments: 1: A string to compare against...
#            2: ...this string
# Returns:   Returns $(true) if the two strings are not the same
# ----------------------------------------------------------------------------
sne = $(call not,$(call seq,$1,$2))

# End from gmsl

# Define comma symbol so we can repace it with a variable
comma :=,

# Signature
last_target :=

dump_var = $$(eval $1 := $($1))

define new_rule
@echo '$(call map,dump_var,@ < *)' > $S
@$(if $(wildcard $F),,touch $F)
@echo $@: $F >> $S
endef

define do
$(eval S := $(BLDDIR)/$*.sig)$(eval F := $(BLDDIR)/$*.force)$(eval C := $1)
$(if $(call sne,$@,$(last_target)),$(call new_rule),$(eval last_target := $@))
@echo '$$(if $$(call sne,$$(sort $1),$(sort $(subst $(comma),$$(comma),$C))),$$(shell touch $F))' >> $S
$Q$C
endef

# end of Signature


# }
else # ifndef NO_SDK_DEPS
# {
# No dependency files, faster compile times
# no partial compile support
DEPS_SED =
DEPS_OPT =
DEPS_CPY =
DEPS_CMD = /bin/true

define do
$(eval C := $1)
$Q$C
endef

# }
endif

#
# Default Build rules for .c --> .o, leaving the binary in BLDDIR/X.o,
# even if file not built from directory of source.
#
ifeq ($(FAST),1)
# {
${BLDDIR}/%.o: %.c
# }
else
# {
ifdef GENERATE_C_FILES
# {
${BLDDIR}/%.o: %.c
# }
else
# {

${BLDDIR}/%.o: %.c
# }
endif
# }
endif
# echo Compiling needed to properly process errors 
	@$Q$(ECHO) Compiling ${LOCALDIR}/$< 
	$Q$(MKDIR) $(BLDDIR)/
	$Q$(RM) -f $@
# 55 is VERY different
ifeq ($(VX_VERSION),55)
# {
	$Q$(CC) -M $(CFLAGS) $(EXTRA_CFLAGS)  $(realpath $<) > $(BLDDIR)/$*.d && ($(DEPS_CMD))
	$(call do,$$(CC) $$(CFLAGS) $$(EXTRA_CFLAGS) -o $$@  -c $$(realpath $$<))
# }
else
# {
	$(call do,$$(CC) $$(DEPS_OPT) $$(CFLAGS) $$(EXTRA_CFLAGS) -o $$@ -c $$(realpath $$<))  && ($(DEPS_CMD))
# }
endif

${BLDDIR}/%.o: %.s
ifdef QUIET
# {
	@$(ECHO) Assembling ${LOCALDIR}/$<
# }
endif
	$Q$(CC) ${CFLAGS} ${EXTRA_CFLAGS} -o $@ -c $(realpath $<)

${BLDDIR}/%.o: %.cpp
ifdef QUIET
# {
	@$(ECHO) Compiling ${LOCALDIR}/$<
# }
endif
	$Q$(CXX) ${CXXFLAGS}  -o $@ -c $(realpath $<)

${BLDDIR}/%.o: %.cc ${BLDDIR}/.tree
ifdef QUIET
# {
	@$(ECHO) Compiling ${LOCALDIR}/$<
# }
endif
	$Q$(CXX) ${CXXFLAGS} -o $@ -c $(realpath $<)

#
# Cause "make foo.o" in any subdirectory to put the object in the build
# directory instead of the local directory.
#
%.o: ${BLDDIR}/%.o
	@

#
# Borland/NT
#
ifeq ($(TOOLS),Borland)
# {
${BLDDIR}/%.obj: %.c
	bcc32 -D__BORLAND__ $(CFGFLAGS) \
		-I$(subst /,\,$(SDK)\include) \
		$(SYSINCLUDES) -o$@ -c $<
# }
endif

#
# Java Support
#
JAVAC	= /bin/javac
JAVACFLAGS= -nowarn

${BLDDIR}/%.class: %.java
	$(JAVAC) ${JAVACFLAGS} -d ${BLDDIR} $<

%.Z: %
	@$(ECHO) Compressing $< .....
	@$(COMPRESS) -c $< > $@

%.gz: %
	@$(ECHO) Compressing $< .....
	@$(GZIP) -c $< > $@


#
# Some Basic tools
#
INSTALL = /usr/ucb/install
INSTALLFLAGS =
CTAGS   = ctags
ETAGS	= etags

#
# List of directories where built objects live.
# (we are not making the export directories for now)
#
#DIRS =	${BLDDIR} ${EXPDIR}/lib ${EXPDIR}/bin ${EXPDIR}/include
DIRS =	${BLDDIR}

#
# Targets for build
#
include ${SDK}/make/Make.targets

ifeq (C_COMPILER,$(MAKECMDGOALS))
# {
C_COMPILER:
	@echo $(CC)
# }
endif

ifeq (CXX_COMPILER,$(MAKECMDGOALS))
# {
CXX_COMPILER:
	@echo $(CXX)
# }
endif

#
# Required for building PHYMOD library
#
ifeq (1,$(BUILD_PHYMOD))
# {
export CC
export AR
export ARFLAGS
export CROSS_COMPILE
export PHYMOD_BLDDIR = $(LIBDIR)
export PHYMOD_OBJDIR = $(BLDDIR)
export PHYMOD_EPIL_BLDDIR = $(LIBDIR)
export PHYMOD_EPIL_OBJDIR = $(BLDDIR)
export PHYMOD_CPPFLAGS = $(CFLAGS)
export PHYMOD_MAKE_RULES = $(SDK)/make/Make.phymod
# }
endif
